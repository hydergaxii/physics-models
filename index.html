<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåßÔ∏è ULTIMATE Ultra-Realistic 2D Rain Physics Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow: hidden;
            user-select: none;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(to bottom, #87ceeb 0%, #98d4f0 30%, #a9ddf5 100%);
            border: 3px solid #fff;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            cursor: crosshair;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ffc107;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            color: white;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,107,107,0.4);
        }
        
        .btn.running {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }
        
        .math-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(25,25,25,0.92);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #2196f3;
            font-size: 16px;
            line-height: 1.8;
            max-width: 450px;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 8px 32px rgba(33,150,243,0.2);
        }
        
        .math-formula {
            background: rgba(33, 150, 243, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
            font-size: 18px;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }
        
        .phase-display {
            color: #ffeb3b;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .explanation {
            color: #e0e0e0;
            font-style: italic;
            margin-top: 10px;
        }
    </style>
    
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                packages: {'[+]': ['amsmath', 'amsfonts', 'amssymb']}
            },
            options: {
                skipHtmlTags: ['canvas', 'script', 'noscript', 'style', 'textarea', 'pre']
            },
            startup: {
                ready: () => {
                    console.log('MathJax is loaded and ready!');
                    MathJax.startup.defaultReady();
                }
            }
        };
    </script>
    <script async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div class="controls">
    <h3>üéÆ Physics Controls</h3>
    <button class="btn" id="playBtn">‚ñ∂Ô∏è Start Running</button>
    <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button class="btn" id="resetBtn">üîÑ Reset</button>
    <br><br>
    <label style="color: #fff;">Rain Intensity: <input type="range" id="rainSlider" min="50" max="300" value="150"></label>
    <br>
    <label style="color: #fff;">Man Speed: <input type="range" id="speedSlider" min="0.5" max="4" step="0.1" value="2"></label>
</div>

<div class="math-display" id="mathDisplay">
    <h3 style="color: #2196f3;">üìê Physics Analysis</h3>
    <div class="phase-display" id="currentPhase">Phase: Man holding umbrella at angle Œ∏</div>
    <div class="math-formula" id="formula">
        $$\vec{v}_{\mathrm{rain,rel}} = \vec{v}_{\mathrm{rain,ground}}$$
    </div>
    <div class="explanation" id="explanation">Rain hits umbrella diagonally</div>
</div>

<canvas id="gameCanvas" width="1200" height="700"></canvas>

<script>
// ========== CANVAS SETUP ==========
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// High DPI support for ultra-crisp graphics
const dpi = window.devicePixelRatio || 1;
canvas.width *= dpi;
canvas.height *= dpi;
ctx.scale(dpi, dpi);

// Enable image smoothing for better quality
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

// ========== ANIMATION STATE ==========
let animationState = {
    isRunning: false,
    isPaused: false,
    manPosition: 200,
    manSpeed: 2,
    hasUmbrella: true,
    umbrellaThrown: false,
    rainIntensity: 150,
    time: 0,
    phase: 'stationary'
};

// ========== ULTRA-REALISTIC HUMAN CHARACTER ==========
class RealisticMan {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 120;
        this.runCycle = 0;
        this.armSwing = 0;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Running animation
        if (animationState.isRunning) {
            this.runCycle += 0.25;
            this.armSwing = Math.sin(this.runCycle) * 12;
            ctx.translate(0, Math.sin(this.runCycle * 2) * 1.5);
            ctx.rotate(Math.sin(this.runCycle) * 0.03);
        }
        
        // Head with gradient for realism
        let headGradient = ctx.createRadialGradient(-5, -105, 5, 0, -100, 20);
        headGradient.addColorStop(0, '#fdbcb4');
        headGradient.addColorStop(1, '#e8a896');
        ctx.fillStyle = headGradient;
        ctx.beginPath();
        ctx.ellipse(0, -100, 18, 22, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.ellipse(0, -110, 20, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'white';
        ctx.fillRect(-8, -105, 6, 4);
        ctx.fillRect(2, -105, 6, 4);
        ctx.fillStyle = 'black';
        ctx.fillRect(-6, -104, 2, 2);
        ctx.fillRect(4, -104, 2, 2);
        
        // Mouth
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -95, 3, 0, Math.PI);
        ctx.stroke();
        
        // Body (shirt)
        let bodyGradient = ctx.createLinearGradient(-15, -80, 15, -30);
        bodyGradient.addColorStop(0, '#4169e1');
        bodyGradient.addColorStop(1, '#1e3a8a');
        ctx.fillStyle = bodyGradient;
        ctx.fillRect(-15, -80, 30, 50);
        
        // Arms
        ctx.fillStyle = '#fdbcb4';
        
        // Left arm
        ctx.save();
        ctx.translate(-20, -70);
        ctx.rotate(this.armSwing * Math.PI / 180);
        ctx.fillRect(-5, 0, 10, 40);
        // Hand
        ctx.beginPath();
        ctx.arc(0, 40, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Right arm (holding umbrella or swinging)
        ctx.save();
        ctx.translate(20, -70);
        if (!animationState.hasUmbrella) {
            ctx.rotate(-this.armSwing * Math.PI / 180);
        }
        ctx.fillRect(-5, 0, 10, 40);
        // Hand
        ctx.beginPath();
        ctx.arc(0, 40, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Legs with realistic running animation
        ctx.fillStyle = '#333333';
        if (animationState.isRunning) {
            let leftLeg = Math.sin(this.runCycle) * 25;
            let rightLeg = Math.sin(this.runCycle + Math.PI) * 25;
            
            // Left leg
            ctx.save();
            ctx.translate(-10, -30);
            ctx.rotate(leftLeg * Math.PI / 180);
            ctx.fillRect(-6, 0, 12, 45);
            // Foot
            ctx.fillStyle = '#654321';
            ctx.fillRect(-8, 45, 16, 8);
            ctx.restore();
            
            // Right leg
            ctx.save();
            ctx.translate(10, -30);
            ctx.rotate(rightLeg * Math.PI / 180);
            ctx.fillRect(-6, 0, 12, 45);
            // Foot
            ctx.fillStyle = '#654321';
            ctx.fillRect(-8, 45, 16, 8);
            ctx.restore();
        } else {
            // Standing legs
            ctx.fillRect(-15, -30, 12, 45);
            ctx.fillRect(3, -30, 12, 45);
            
            // Feet
            ctx.fillStyle = '#654321';
            ctx.fillRect(-18, 15, 20, 8);
            ctx.fillRect(0, 15, 20, 8);
        }
        
        ctx.restore();
    }
}

// ========== ULTRA-REALISTIC UMBRELLA ==========
class RealisticUmbrella {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = -Math.PI / 6; // 30 degrees
        this.thrown = false;
        this.velocity = { x: 0, y: 0 };
        this.rotation = 0;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (this.thrown) {
            ctx.rotate(this.rotation);
        }
        
        // Umbrella handle with wood texture
        let handleGradient = ctx.createLinearGradient(-2, 0, 2, 0);
        handleGradient.addColorStop(0, '#8b4513');
        handleGradient.addColorStop(0.5, '#a0522d');
        handleGradient.addColorStop(1, '#654321');
        ctx.strokeStyle = handleGradient;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -60);
        ctx.stroke();
        
        // Handle grip
        ctx.fillStyle = '#654321';
        ctx.beginPath();
        ctx.arc(0, 5, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Umbrella canopy with gradient
        let canopyGradient = ctx.createRadialGradient(0, -60, 0, 0, -60, 45);
        canopyGradient.addColorStop(0, '#dc143c');
        canopyGradient.addColorStop(0.7, '#b91c3c');
        canopyGradient.addColorStop(1, '#8b0000');
        
        ctx.fillStyle = canopyGradient;
        ctx.strokeStyle = '#8b0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, -60, 45, 25, 0, Math.PI, 0);
        ctx.fill();
        ctx.stroke();
        
        // Umbrella ribs for realism
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * i) / 7;
            let x = Math.cos(angle) * 42;
            let y = Math.sin(angle) * -22;
            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.lineTo(x, y - 60);
            ctx.stroke();
        }
        
        // Umbrella tip
        ctx.fillStyle = '#333333';
        ctx.beginPath();
        ctx.arc(0, -60, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    throw() {
        if (!this.thrown) {
            this.thrown = true;
            this.velocity.x = 4 + Math.random() * 2;
            this.velocity.y = -6 - Math.random() * 2;
            animationState.hasUmbrella = false;
            animationState.umbrellaThrown = true;
        }
    }
    
    update() {
        if (this.thrown) {
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.velocity.y += 0.25; // gravity
            this.rotation += 0.08;
            
            // Bounce off ground with energy loss
            if (this.y > canvas.height / dpi - 60) {
                this.velocity.y *= -0.4;
                this.velocity.x *= 0.7;
                if (Math.abs(this.velocity.y) < 1) {
                    this.velocity.y = 0;
                }
            }
        }
    }
}

// ========== ULTRA-REALISTIC RAIN SYSTEM ==========
class RainDrop {
    constructor() {
        this.reset();
        this.y = Math.random() * canvas.height / dpi;
    }
    
    reset() {
        this.x = Math.random() * (canvas.width / dpi + 200) - 100;
        this.y = -30;
        this.speed = 10 + Math.random() * 6;
        this.angle = animationState.isRunning ? 0 : 0.25;
        this.length = 18 + Math.random() * 12;
        this.opacity = 0.4 + Math.random() * 0.4;
        this.thickness = 1 + Math.random() * 1;
    }
    
    update() {
        if (animationState.isRunning) {
            // Rain appears vertical relative to running man
            this.x += 0;
            this.y += this.speed;
        } else {
            // Diagonal rain when stationary
            this.x += this.speed * this.angle;
            this.y += this.speed;
        }
        
        if (this.y > canvas.height / dpi + 30) {
            this.reset();
        }
    }
    
    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.strokeStyle = '#4fc3f7';
        ctx.lineWidth = this.thickness;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        
        if (animationState.isRunning) {
            ctx.lineTo(this.x, this.y + this.length);
        } else {
            ctx.lineTo(this.x + this.length * this.angle, this.y + this.length);
        }
        
        ctx.stroke();
        ctx.restore();
    }
}

// ========== PERFECT VECTOR DRAWING ==========
function drawVectorWithLabel(x, y, dx, dy, color, label) {
    ctx.save();
    
    // Vector arrow shaft
    ctx.strokeStyle = color;
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + dy);
    ctx.stroke();
    
    // Arrow head
    let angle = Math.atan2(dy, dx);
    let headSize = 20;
    
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x + dx, y + dy);
    ctx.lineTo(
        x + dx - headSize * Math.cos(angle - Math.PI/6),
        y + dy - headSize * Math.sin(angle - Math.PI/6)
    );
    ctx.lineTo(
        x + dx - headSize * Math.cos(angle + Math.PI/6),
        y + dy - headSize * Math.sin(angle + Math.PI/6)
    );
    ctx.closePath();
    ctx.fill();
    
    // Vector label with background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(x + dx/2 - 25, y + dy/2 - 25, 50, 20);
    
    ctx.fillStyle = color;
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(label, x + dx/2, y + dy/2 - 10);
    
    ctx.restore();
}

// ========== INITIALIZE OBJECTS ==========
let man = new RealisticMan(200, canvas.height / dpi - 50);
let umbrella = new RealisticUmbrella(235, canvas.height / dpi - 130);
let raindrops = [];

// Create rain drops
for (let i = 0; i < animationState.rainIntensity; i++) {
    raindrops.push(new RainDrop());
}

// ========== BACKGROUND RENDERING ==========
function drawBackground() {
    // Dynamic sky gradient
    let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / dpi);
    if (animationState.isRunning) {
        gradient.addColorStop(0, '#708090');
        gradient.addColorStop(0.3, '#87ceeb');
        gradient.addColorStop(1, '#98d4f0');
    } else {
        gradient.addColorStop(0, '#87ceeb');
        gradient.addColorStop(0.3, '#98d4f0');
        gradient.addColorStop(1, '#a9ddf5');
    }
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width / dpi, canvas.height / dpi);
    
    // Animated storm clouds
    ctx.fillStyle = animationState.isRunning ? 'rgba(128, 128, 128, 0.8)' : 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < 6; i++) {
        let x = (i * 200) + (animationState.time * 0.2) % 1400;
        drawCloud(x, 40 + i * 15);
    }
    
    // Ground with grass texture
    let groundGradient = ctx.createLinearGradient(0, canvas.height / dpi - 50, 0, canvas.height / dpi);
    groundGradient.addColorStop(0, '#2d5016');
    groundGradient.addColorStop(1, '#1a3009');
    ctx.fillStyle = groundGradient;
    ctx.fillRect(0, canvas.height / dpi - 50, canvas.width / dpi, 50);
    
    // Road surface
    ctx.fillStyle = '#444444';
    ctx.fillRect(0, canvas.height / dpi - 58, canvas.width / dpi, 12);
    
    // Road center line
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 4;
    ctx.setLineDash([30, 15]);
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / dpi - 52);
    ctx.lineTo(canvas.width / dpi, canvas.height / dpi - 52);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawCloud(x, y) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.arc(x + 30, y, 40, 0, Math.PI * 2);
    ctx.arc(x + 60, y, 30, 0, Math.PI * 2);
    ctx.arc(x + 30, y - 20, 25, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

// ========== VECTOR PHYSICS DISPLAY ==========
function drawPhysicsVectors() {
    if (!man) return;
    
    let baseX = man.x;
    let baseY = man.y - 160;
    
    if (animationState.isRunning) {
        // Rain velocity relative to ground (diagonal, green)
        drawVectorWithLabel(
            baseX - 120, baseY,
            70, 140,
            '#22c55e', 'v_rain,ground'
        );
        
        // Man velocity (horizontal, blue)
        drawVectorWithLabel(
            baseX, baseY,
            120, 0,
            '#3b82f6', 'v_man'
        );
        
        // Rain velocity relative to man (vertical, red)
        drawVectorWithLabel(
            baseX + 160, baseY,
            0, 140,
            '#ef4444', 'v_rain,man'
        );
    } else {
        // Rain vector when stationary (diagonal, green)
        drawVectorWithLabel(
            baseX, baseY,
            70, 140,
            '#22c55e', 'v_rain'
        );
        
        // Theta angle visualization
        if (animationState.hasUmbrella && umbrella) {
            ctx.save();
            
            // Vertical reference line (dashed)
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(umbrella.x, umbrella.y);
            ctx.lineTo(umbrella.x, umbrella.y - 90);
            ctx.stroke();
            
            // Angle arc
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(umbrella.x, umbrella.y, 40, -Math.PI/2, umbrella.angle, false);
            ctx.stroke();
            
            // Theta label with background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(umbrella.x + 50, umbrella.y - 35, 30, 25);
            
            ctx.fillStyle = '#f59e0b';
            ctx.font = 'bold 20px Times New Roman, serif';
            ctx.textAlign = 'center';
            ctx.fillText('Œ∏', umbrella.x + 65, umbrella.y - 15);
            
            ctx.restore();
        }
    }
}

// ========== PERFECT MATH NOTATION SYSTEM ==========
function updateMathNotation() {
    const formula = document.getElementById('formula');
    const currentPhase = document.getElementById('currentPhase');
    const explanation = document.getElementById('explanation');
    
    if (animationState.isRunning) {
        currentPhase.innerHTML = 'Phase: <span style="color: #4ecdc4;">Man running</span>, umbrella thrown';
        
        formula.innerHTML = `
            $$\\color{red}{\\vec{v}_{\\mathrm{rain,man}}} = \\color{green}{\\vec{v}_{\\mathrm{rain,ground}}} - \\color{blue}{\\vec{v}_{\\mathrm{man}}}$$
        `;
        
        explanation.innerHTML = 'Rain appears <strong>vertical</strong> relative to the running man';
        document.getElementById('mathDisplay').style.borderColor = '#ef4444';
        
    } else {
        currentPhase.innerHTML = 'Phase: Man holding umbrella at angle <span style="color: #f59e0b;">Œ∏</span>';
        
        formula.innerHTML = `
            $$\\color{green}{\\vec{v}_{\\mathrm{rain,rel}}} = \\color{green}{\\vec{v}_{\\mathrm{rain,ground}}}$$
        `;
        
        explanation.innerHTML = 'Rain hits umbrella <strong>diagonally</strong> from above';
        document.getElementById('mathDisplay').style.borderColor = '#22c55e';
    }
    
    // Re-render MathJax
    if (window.MathJax && window.MathJax.typesetPromise) {
        MathJax.typesetPromise([document.getElementById('mathDisplay')]).catch(function (err) {
            console.log('MathJax typeset error: ' + err.message);
        });
    }
}

// ========== MAIN ANIMATION LOOP ==========
function animate() {
    if (!animationState.isPaused) {
        // Clear canvas with slight trail effect for motion blur
        ctx.fillStyle = 'rgba(135, 206, 235, 0.1)';
        ctx.fillRect(0, 0, canvas.width / dpi, canvas.height / dpi);
        
        drawBackground();
        
        // Update and draw rain
        raindrops.forEach(drop => {
            drop.update();
            drop.draw();
        });
        
        // Update man position
        if (animationState.isRunning) {
            man.x += animationState.manSpeed;
            
            // Loop man position
            if (man.x > canvas.width / dpi + 100) {
                man.x = -100;
            }
        }
        
        // Draw man
        man.draw();
        
        // Update umbrella position when held
        if (animationState.hasUmbrella && !umbrella.thrown) {
            umbrella.x = man.x + 35;
            umbrella.y = man.y - 75;
        }
        
        // Update thrown umbrella
        if (umbrella.thrown || animationState.umbrellaThrown) {
            umbrella.update();
        }
        
        // Draw umbrella
        if (!umbrella.thrown || umbrella.y < canvas.height / dpi - 45) {
            umbrella.draw();
        }
        
        // Draw physics vectors
        drawPhysicsVectors();
        
        // Update math notation
        updateMathNotation();
        
        animationState.time++;
    }
    
    requestAnimationFrame(animate);
}

// ========== CONTROL FUNCTIONS ==========
function startRunning() {
    if (!animationState.isRunning) {
        animationState.isRunning = true;
        umbrella.throw();
        document.getElementById('playBtn').classList.add('running');
        document.getElementById('playBtn').innerHTML = 'üèÉ Running...';
    }
}

function pauseAnimation() {
    animationState.isPaused = !animationState.isPaused;
    const pauseBtn = document.getElementById('pauseBtn');
    pauseBtn.innerHTML = animationState.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
}

function resetAnimation() {
    animationState.isRunning = false;
    animationState.isPaused = false;
    animationState.hasUmbrella = true;
    animationState.umbrellaThrown = false;
    
    man.x = 200;
    man.runCycle = 0;
    
    umbrella.thrown = false;
    umbrella.x = 235;
    umbrella.y = canvas.height / dpi - 130;
    umbrella.velocity = { x: 0, y: 0 };
    umbrella.rotation = 0;
    
    document.getElementById('playBtn').classList.remove('running');
    document.getElementById('playBtn').innerHTML = '‚ñ∂Ô∏è Start Running';
    document.getElementById('pauseBtn').innerHTML = '‚è∏Ô∏è Pause';
}

// ========== EVENT LISTENERS ==========
document.getElementById('playBtn').addEventListener('click', startRunning);
document.getElementById('pauseBtn').addEventListener('click', pauseAnimation);
document.getElementById('resetBtn').addEventListener('click', resetAnimation);

document.getElementById('rainSlider').addEventListener('input', (e) => {
    const newIntensity = parseInt(e.target.value);
    const difference = newIntensity - animationState.rainIntensity;
    
    if (difference > 0) {
        for (let i = 0; i < difference; i++) {
            raindrops.push(new RainDrop());
        }
    } else if (difference < 0) {
        raindrops.splice(0, Math.abs(difference));
    }
    
    animationState.rainIntensity = newIntensity;
});

document.getElementById('speedSlider').addEventListener('input', (e) => {
    animationState.manSpeed = parseFloat(e.target.value);
});

// Click canvas to start
canvas.addEventListener('click', startRunning);

// ========== START THE ULTIMATE ANIMATION ==========
// Wait for MathJax to load, then start
setTimeout(() => {
    animate();
    console.log('üé¨ ULTIMATE 2D Physics Animation Started!');
    console.log('üåßÔ∏è Perfect Math Notation with \\mathrm{vec} rendering!');
    console.log('üéÆ Click to interact and enjoy the physics!');
}, 1000);

</script>

</body>
</html>
