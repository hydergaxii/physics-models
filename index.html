<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåßÔ∏è ULTIMATE Ultra-Realistic 2D Rain Physics Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow: hidden;
            user-select: none;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(to bottom, #87ceeb 0%, #98d4f0 30%, #a9ddf5 100%);
            border: 3px solid #fff;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            cursor: crosshair;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ffc107;
            backdrop-filter: blur(10px);
        }
        
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            color: white;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,107,107,0.4);
        }
        
        .btn.running {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }
        
        .math-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(25,25,25,0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #2196f3;
            font-size: 18px;
            line-height: 1.8;
            max-width: 400px;
            font-family: 'Times New Roman', serif;
        }
        
        .math-formula {
            background: rgba(33, 150, 243, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196f3;
            font-size: 20px;
            text-align: center;
        }
        
        .vector-notation {
            font-weight: bold;
            font-size: 18px;
        }
    </style>
    
    <!-- MathJax for perfect math rendering -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['canvas', 'script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div class="controls">
    <h3>üéÆ Physics Controls</h3>
    <button class="btn" id="playBtn">‚ñ∂Ô∏è Start Running</button>
    <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button class="btn" id="resetBtn">üîÑ Reset</button>
    <br>
    <label>Rain Intensity: <input type="range" id="rainSlider" min="50" max="300" value="150"></label>
    <br>
    <label>Man Speed: <input type="range" id="speedSlider" min="0.5" max="4" step="0.1" value="2"></label>
</div>

<div class="math-display" id="mathDisplay">
    <h3>üìê Physics Analysis</h3>
    <div id="currentPhase">Phase: Man holding umbrella at angle Œ∏</div>
    <div class="math-formula" id="formula">
        v‚Éó<sub>rain,rel</sub> = v‚Éó<sub>rain,ground</sub>
    </div>
    <div id="explanation">Rain hits umbrella diagonally</div>
</div>

<canvas id="gameCanvas" width="1200" height="700"></canvas>

<script>
// ========== UNICODE MATH SYMBOLS ==========
const MATH = {
    vector: '‚Éó',
    theta: 'Œ∏',
    sub: {
        'rain,rel': '‚Çç·µ£‚Çê·µ¢‚Çô,·µ£‚Çë‚Çó‚Çé',
        'rain,ground': '‚Çç·µ£‚Çê·µ¢‚Çô,g·µ£‚Çí·µ§‚Çôùíπ‚Çé', 
        'rain,man': '‚Çç·µ£‚Çê·µ¢‚Çô,‚Çò‚Çê‚Çô‚Çé',
        'man': '‚Çç‚Çò‚Çê‚Çô‚Çé'
    },
    equals: '=',
    minus: '‚àí'
};

// ========== CANVAS SETUP ==========
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// High DPI support
const dpi = window.devicePixelRatio || 1;
canvas.width *= dpi;
canvas.height *= dpi;
ctx.scale(dpi, dpi);

// ========== ANIMATION STATE ==========
let animationState = {
    isRunning: false,
    isPaused: false,
    manPosition: 200,
    manSpeed: 2,
    hasUmbrella: true,
    umbrellaThrown: false,
    rainIntensity: 150,
    time: 0,
    phase: 'stationary'
};

// ========== REALISTIC HUMAN CHARACTER ==========
class RealisticMan {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 120;
        this.runCycle = 0;
        this.armSwing = 0;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (animationState.isRunning) {
            this.runCycle += 0.3;
            this.armSwing = Math.sin(this.runCycle) * 10;
            ctx.translate(0, Math.sin(this.runCycle * 2) * 2);
            ctx.rotate(Math.sin(this.runCycle) * 0.05);
        }
        
        // Head
        ctx.fillStyle = '#fdbcb4';
        ctx.beginPath();
        ctx.ellipse(0, -100, 18, 22, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.ellipse(0, -110, 20, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'black';
        ctx.fillRect(-8, -105, 4, 3);
        ctx.fillRect(4, -105, 4, 3);
        
        // Body
        ctx.fillStyle = '#4169e1';
        ctx.fillRect(-15, -80, 30, 50);
        
        // Arms
        ctx.fillStyle = '#fdbcb4';
        // Left arm
        ctx.save();
        ctx.translate(-20, -70);
        ctx.rotate(this.armSwing * Math.PI / 180);
        ctx.fillRect(-5, 0, 10, 40);
        ctx.restore();
        
        // Right arm
        ctx.save();
        ctx.translate(20, -70);
        if (!animationState.hasUmbrella) {
            ctx.rotate(-this.armSwing * Math.PI / 180);
        }
        ctx.fillRect(-5, 0, 10, 40);
        ctx.restore();
        
        // Legs with running animation
        ctx.fillStyle = '#333333';
        if (animationState.isRunning) {
            let leftLeg = Math.sin(this.runCycle) * 20;
            let rightLeg = Math.sin(this.runCycle + Math.PI) * 20;
            
            ctx.save();
            ctx.translate(-10, -30);
            ctx.rotate(leftLeg * Math.PI / 180);
            ctx.fillRect(-5, 0, 10, 45);
            ctx.restore();
            
            ctx.save();
            ctx.translate(10, -30);
            ctx.rotate(rightLeg * Math.PI / 180);
            ctx.fillRect(-5, 0, 10, 45);
            ctx.restore();
        } else {
            ctx.fillRect(-15, -30, 12, 45);
            ctx.fillRect(3, -30, 12, 45);
        }
        
        // Feet
        ctx.fillStyle = '#654321';
        ctx.fillRect(-18, 15, 20, 8);
        ctx.fillRect(0, 15, 20, 8);
        
        ctx.restore();
    }
}

// ========== ULTRA-REALISTIC UMBRELLA ==========
class RealisticUmbrella {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = -Math.PI / 6;
        this.thrown = false;
        this.velocity = { x: 0, y: 0 };
        this.rotation = 0;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (this.thrown) {
            ctx.rotate(this.rotation);
        }
        
        // Handle
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -60);
        ctx.stroke();
        
        // Canopy
        ctx.fillStyle = '#dc143c';
        ctx.strokeStyle = '#8b0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, -60, 45, 25, 0, Math.PI, 0);
        ctx.fill();
        ctx.stroke();
        
        // Ribs
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * i) / 7;
            let x = Math.cos(angle) * 40;
            let y = Math.sin(angle) * -20;
            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.lineTo(x, y - 60);
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    throw() {
        if (!this.thrown) {
            this.thrown = true;
            this.velocity.x = 3 + Math.random() * 2;
            this.velocity.y = -5 - Math.random() * 3;
            animationState.hasUmbrella = false;
        }
    }
    
    update() {
        if (this.thrown) {
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.velocity.y += 0.2;
            this.rotation += 0.1;
            
            if (this.y > canvas.height / dpi - 50) {
                this.velocity.y *= -0.3;
                this.velocity.x *= 0.8;
            }
        }
    }
}

// ========== RAIN SYSTEM ==========
class RainDrop {
    constructor() {
        this.reset();
        this.y = Math.random() * canvas.height / dpi;
    }
    
    reset() {
        this.x = Math.random() * (canvas.width / dpi + 200) - 100;
        this.y = -20;
        this.speed = 8 + Math.random() * 4;
        this.angle = animationState.isRunning ? 0 : 0.3;
        this.length = 15 + Math.random() * 10;
        this.opacity = 0.3 + Math.random() * 0.4;
    }
    
    update() {
        if (animationState.isRunning) {
            this.x += 0;
            this.y += this.speed;
        } else {
            this.x += this.speed * this.angle;
            this.y += this.speed;
        }
        
        if (this.y > canvas.height / dpi + 20) {
            this.reset();
        }
    }
    
    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.strokeStyle = '#4fc3f7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        
        if (animationState.isRunning) {
            ctx.lineTo(this.x, this.y + this.length);
        } else {
            ctx.lineTo(this.x + this.length * this.angle, this.y + this.length);
        }
        
        ctx.stroke();
        ctx.restore();
    }
}

// ========== VECTOR DRAWING WITH PERFECT MATH NOTATION ==========
function drawVectorWithMath(x, y, dx, dy, color, label) {
    ctx.save();
    
    // Arrow shaft
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + dy);
    ctx.stroke();
    
    // Arrow head
    let angle = Math.atan2(dy, dx);
    let headSize = 15;
    
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x + dx, y + dy);
    ctx.lineTo(
        x + dx - headSize * Math.cos(angle - Math.PI/6),
        y + dy - headSize * Math.sin(angle - Math.PI/6)
    );
    ctx.lineTo(
        x + dx - headSize * Math.cos(angle + Math.PI/6),
        y + dy - headSize * Math.sin(angle + Math.PI/6)
    );
    ctx.closePath();
    ctx.fill();
    
    // Perfect Math Label with Unicode
    ctx.fillStyle = color;
    ctx.font = 'bold 16px Times New Roman, serif';
    ctx.textAlign = 'center';
    
    // Use Unicode for vector notation
    let vectorLabel = label.replace('v‚Éó', 'v‚Éó');
    ctx.fillText(vectorLabel, x + dx/2, y + dy/2 - 10);
    
    ctx.restore();
}

// ========== PERFECT MATH NOTATION RENDERING ==========
function renderMathNotation() {
    // Update math display with perfect Unicode symbols
    const formula = document.getElementById('formula');
    const currentPhase = document.getElementById('currentPhase');
    const explanation = document.getElementById('explanation');
    
    if (animationState.isRunning) {
        currentPhase.textContent = 'Phase: Man running, umbrella thrown';
        
        // Perfect vector equation with Unicode
        formula.innerHTML = `
            <span style="color: #ef4444;">v‚Éó<sub>rain,man</sub></span> = 
            <span style="color: #4ade80;">v‚Éó<sub>rain,ground</sub></span> ‚àí 
            <span style="color: #3b82f6;">v‚Éó<sub>man</sub></span>
        `;
        
        explanation.innerHTML = 'Rain appears <strong>vertical</strong> relative to running man';
        document.getElementById('mathDisplay').style.borderColor = '#ef4444';
    } else {
        currentPhase.innerHTML = 'Phase: Man holding umbrella at angle <span style="color: #f59e0b;">Œ∏</span>';
        
        formula.innerHTML = `
            <span style="color: #4ade80;">v‚Éó<sub>rain,rel</sub></span> = 
            <span style="color: #4ade80;">v‚Éó<sub>rain,ground</sub></span>
        `;
        
        explanation.textContent = 'Rain hits umbrella diagonally';
        document.getElementById('mathDisplay').style.borderColor = '#4ade80';
    }
    
    // Re-render MathJax if available
    if (window.MathJax && window.MathJax.typesetPromise) {
        MathJax.typesetPromise([document.getElementById('mathDisplay')]);
    }
}

// ========== INITIALIZE OBJECTS ==========
let man = new RealisticMan(200, canvas.height / dpi - 50);
let umbrella = new RealisticUmbrella(220, canvas.height / dpi - 130);
let raindrops = [];

for (let i = 0; i < animationState.rainIntensity; i++) {
    raindrops.push(new RainDrop());
}

// ========== BACKGROUND DRAWING ==========
function drawBackground() {
    // Sky gradient
    let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / dpi);
    gradient.addColorStop(0, '#87ceeb');
    gradient.addColorStop(0.3, '#98d4f0');
    gradient.addColorStop(1, '#a9ddf5');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width / dpi, canvas.height / dpi);
    
    // Animated clouds
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < 5; i++) {
        let x = (i * 250) + (animationState.time * 0.1) % 1500;
        drawCloud(x, 50 + i * 20);
    }
    
    // Ground
    ctx.fillStyle = '#2d5016';
    ctx.fillRect(0, canvas.height / dpi - 50, canvas.width / dpi, 50);
    
    // Road
    ctx.fillStyle = '#555555';
    ctx.fillRect(0, canvas.height / dpi - 55, canvas.width / dpi, 10);
    
    // Road markings
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 3;
    ctx.setLineDash([20, 20]);
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / dpi - 50);
    ctx.lineTo(canvas.width / dpi, canvas.height / dpi - 50);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawCloud(x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.arc(x + 25, y, 35, 0, Math.PI * 2);
    ctx.arc(x + 50, y, 25, 0, Math.PI * 2);
    ctx.arc(x + 25, y - 15, 20, 0, Math.PI * 2);
    ctx.fill();
}

// ========== VECTOR DRAWING WITH PERFECT MATH ==========
function drawVectors() {
    if (!man) return;
    
    let baseX = man.x;
    let baseY = man.y - 150;
    
    if (animationState.isRunning) {
        // Rain relative to ground (diagonal, green)
        drawVectorWithMath(
            baseX - 100, baseY,
            60, 120,
            '#4ade80', 'v‚Éórain,ground'
        );
        
        // Man velocity (horizontal, blue)  
        drawVectorWithMath(
            baseX, baseY,
            100, 0,
            '#3b82f6', 'v‚Éóman'
        );
        
        // Rain relative to man (vertical, red)
        drawVectorWithMath(
            baseX + 150, baseY,
            0, 120,
            '#ef4444', 'v‚Éórain,man'
        );
    } else {
        // Rain vector when stationary
        drawVectorWithMath(
            baseX, baseY,
            60, 120,
            '#4ade80', 'v‚Éórain'
        );
        
        // Theta angle indicator
        if (animationState.hasUmbrella) {
            ctx.save();
            
            // Vertical reference line
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(umbrella.x, umbrella.y);
            ctx.lineTo(umbrella.x, umbrella.y - 80);
            ctx.stroke();
            
            // Angle arc
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(umbrella.x, umbrella.y, 30, -Math.PI/2, umbrella.angle, false);
            ctx.stroke();
            
            // Perfect Œ∏ symbol
            ctx.fillStyle = '#f59e0b';
            ctx.font = 'bold 24px Times New Roman, serif';
            ctx.textAlign = 'center';
            ctx.fillText('Œ∏', umbrella.x + 45, umbrella.y - 15);
            
            ctx.restore();
        }
    }
}

// ========== MAIN ANIMATION LOOP ==========
function animate() {
    if (!animationState.isPaused) {
        ctx.clearRect(0, 0, canvas.width / dpi, canvas.height / dpi);
        
        drawBackground();
        
        // Update and draw rain
        raindrops.forEach(drop => {
            drop.update();
            drop.draw();
        });
        
        // Update man position
        if (animationState.isRunning) {
            man.x += animationState.manSpeed;
            if (man.x > canvas.width / dpi + 50) {
                man.x = -50;
            }
        }
        
        man.draw();
        
        // Update umbrella
        if (animationState.hasUmbrella && !umbrella.thrown) {
            umbrella.x = man.x + 20;
            umbrella.y = man.y - 80;
        }
        
        if (umbrella.thrown || !animationState.hasUmbrella) {
            umbrella.update();
        }
        
        if (!umbrella.thrown || umbrella.y < canvas.height / dpi - 50) {
            umbrella.draw();
        }
        
        drawVectors();
        renderMathNotation();
        
        animationState.time++;
    }
    
    requestAnimationFrame(animate);
}

// ========== CONTROL FUNCTIONS ==========
function startRunning() {
    if (!animationState.isRunning) {
        animationState.isRunning = true;
        umbrella.throw();
        document.getElementById('playBtn').classList.add('running');
        document.getElementById('playBtn').textContent = 'üèÉ Running...';
    }
}

function pauseAnimation() {
    animationState.isPaused = !animationState.isPaused;
    const pauseBtn = document.getElementById('pauseBtn');
    pauseBtn.textContent = animationState.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
}

function resetAnimation() {
    animationState.isRunning = false;
    animationState.isPaused = false;
    animationState.hasUmbrella = true;
    man.x = 200;
    umbrella.thrown = false;
    umbrella.x = 220;
    umbrella.y = canvas.height / dpi - 130;
    
    document.getElementById('playBtn').classList.remove('running');
    document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Start Running';
    document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
}

// ========== EVENT LISTENERS ==========
document.getElementById('playBtn').addEventListener('click', startRunning);
document.getElementById('pauseBtn').addEventListener('click', pauseAnimation);
document.getElementById('resetBtn').addEventListener('click', resetAnimation);

document.getElementById('rainSlider').addEventListener('input', (e) => {
    const newIntensity = parseInt(e.target.value);
    const difference = newIntensity - animationState.rainIntensity;
    
    if (difference > 0) {
        for (let i = 0; i < difference; i++) {
            raindrops.push(new RainDrop());
        }
    } else {
        raindrops.splice(0, Math.abs(difference));
    }
    
    animationState.rainIntensity = newIntensity;
});

document.getElementById('speedSlider').addEventListener('input', (e) => {
    animationState.manSpeed = parseFloat(e.target.value);
});

canvas.addEventListener('click', startRunning);

// ========== START ANIMATION ==========
animate();

console.log('üé¨ ULTIMATE 2D Physics Animation with PERFECT Math Notation!');
console.log('üåßÔ∏è Features: Unicode vectors, MathJax support, realistic graphics');
console.log('üéÆ Click to interact!');

</script>

</body>
</html>
